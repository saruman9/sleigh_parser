sleigh = _{ SOI ~ spec ~ EOI }

// Ignored things, Errors
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
WHITESPACE = _{ "\r" | " " | "\t" | "\n" }

spec = { pp_position* ~ endiandef ~ ( definition | constructorlike | pp_position )* }
endiandef = { KEY_DEFINE ~ KEY_ENDIAN ~ ASSIGN ~ endian ~ SEMI }
endian = { KEY_BIG | KEY_LITTLE }

definition = {
      (
          aligndef
        | tokendef
        | contextdef
        | spacedef
        | varnodedef
        | bitrangedef
        | pcodeopdef
        | valueattach
        | nameattach
        | varattach
    ) ~ SEMI
}

aligndef = { KEY_DEFINE ~ KEY_ALIGNMENT ~ ASSIGN ~ integer }

tokendef = { KEY_DEFINE ~ KEY_TOKEN ~ identifier ~ LPAREN ~ integer ~ RPAREN ~ fielddefs }
fielddefs = { fielddef* }
fielddef = { strict_id ~ ASSIGN ~ LPAREN ~ integer ~ COMMA ~ integer ~ RPAREN ~ fieldmods }
fieldmods = { fieldmod* }
fieldmod = {
      KEY_SIGNED
    | KEY_HEX
    | KEY_DEC
}

contextdef = { KEY_DEFINE ~ KEY_CONTEXT ~ identifier ~ contextfielddefs }
contextfielddefs = { contextfielddef* }
contextfielddef = { identifier ~ ASSIGN ~ LPAREN ~ integer ~ COMMA ~ integer ~ RPAREN
      ~ contextfieldmods
}
contextfieldmods = { contextfieldmod* }
contextfieldmod = {
      KEY_SIGNED
    | KEY_NOFLOW
    | KEY_HEX
    | KEY_DEC
}

spacedef = { KEY_DEFINE ~ KEY_SPACE ~ identifier ~ spacemods }
spacemods = { spacemod* }
spacemod = {
      typemod
    | sizemod
    | wordsizemod
    | KEY_DEFAULT
}
typemod = { KEY_TYPE ~ ASSIGN ~ type_ }
type_ = _{ identifier }
sizemod = { KEY_SIZE ~ ASSIGN ~ integer }
wordsizemod = { KEY_WORDSIZE ~ ASSIGN ~ integer }

varnodedef = { KEY_DEFINE ~ identifier ~ KEY_OFFSET ~ ASSIGN ~ integer ~ KEY_SIZE ~ ASSIGN
      ~ integer ~ identifierlist }

bitrangedef = { KEY_DEFINE ~ KEY_BITRANGE ~ bitranges }
bitranges = { bitrange+ }
bitrange = { identifier ~ ASSIGN ~ identifier ~ LBRACKET ~ integer ~ COMMA ~ integer
      ~ RBRACKET
}

pcodeopdef = { KEY_DEFINE ~ KEY_PCODEOP ~ identifierlist }

valueattach = { KEY_ATTACH ~ KEY_VALUES ~ identifierlist ~ intblist }

nameattach = { KEY_ATTACH ~ KEY_NAMES ~ identifierlist ~ stringoridentlist }

varattach = { KEY_ATTACH ~ KEY_VARIABLES ~ identifierlist ~ identifierlist }

identifierlist = {
      LBRACKET ~ id_or_wild+ ~ RBRACKET
    | id_or_wild
}
stringoridentlist = {
      LBRACKET ~ stringorident+ ~ RBRACKET
      | stringorident
}
stringorident = {
      id_or_wild
    | qstring
}
intblist = {
      LBRACKET ~ intbpart+ ~ RBRACKET
      | neginteger
}
intbpart = {
      neginteger
    | UNDERSCORE
}
neginteger = {
      integer
    | MINUS ~ integer
}

constructorlike = {
      macrodef
    | withblock
    | constructor
}
macrodef = { KEY_MACRO ~ identifier ~ LPAREN ~ arguments ~ RPAREN ~ semanticbody }
arguments = { oplist? }
oplist = { identifier ~ (COMMA ~ identifier)* }
semanticbody = { "semanticbody" }

withblock = { RES_WITH ~ id_or_nil ~ COLON ~ bitpat_or_nil ~ contextblock ~ LBRACE
      ~ constructorlikelist ~ RBRACE
}
id_or_nil = { identifier? }
bitpat_or_nil = { bitpattern? }
constructorlikelist = { def_or_conslike* }
def_or_conslike = {
      definition
    | constructorlike
}

constructor = { ctorstart ~ bitpattern ~ contextblock ~ ctorsemantic }
ctorsemantic = {
      semanticbody
    | KEY_UNIMPL
}
bitpattern = { pequation }
ctorstart = {
      identifier ~ display
    | display
}
display = { "display" }

contextblock = { (LBRACKET ~ ctxstmts ~ RBRACKET)? }
ctxstmts = { ctxstmt* }
ctxstmt = { (ctxassign | pfuncall) ~ SEMI }
ctxassign = { ctxlval ~ ASSIGN ~ pexpression }
ctxlval = { identifier }
pfuncall = { pexpression_apply }
pequation = { pequation_or }
pequation_or = { pequation_seq ~ (pequation_or_op ~ pequation_seq)* }
pequation_or_op = { PIPE }
pequation_seq = { pequation_and }
pequation_seq_op = { SEMI }
pequation_and = { pequation_ellipsis ~ (pequation_and_op ~ pequation_ellipsis)* }
pequation_and_op = { AMPERSAND }
pequation_ellipsis = {
      ELLIPSIS ~ pequation_ellipsis_right
    | pequation_ellipsis_right
}
pequation_ellipsis_right = {
      (pequation_atomic ~ ELLIPSIS)
      | pequation_atomic
}
pequation_atomic = {
      constraint
      | LPAREN ~ pequation ~ RPAREN
}
constraint = { identifier ~ (constraint_op ~ pexpression2)? }
constraint_op = {
      ASSIGN
    | NOTEQUAL
    | LESS
    | LESSEQUAL
    | GREAT
    | GREATEQUAL
}
pexpression = { pexpression_or }
pexpression_or = { pexpression_xor ~ (pexpression_or_op ~ pexpression_xor)* }
pexpression_or_op = {
      PIPE
      | SPEC_OR
}
pexpression_xor = { pexpression_and ~ (pexpression_xor_op ~ pexpression_and)* }
pexpression_xor_op = {
      CARET
      | SPEC_XOR
}
pexpression_and = { pexpression_shift ~ (pexpression_and_op ~ pexpression_shift)* }
pexpression_and_op = {
      AMPERSAND
      | SPEC_AND
}
pexpression_shift = { pexpression_add ~ (pexpression_shift_op ~ pexpression_add)* }
pexpression_shift_op = {
      LEFT
      | RIGHT
}
pexpression_add = { pexpression_mult ~ (pexpression_add_op ~ pexpression_mult)* }
pexpression_add_op = {
      PLUS
      | MINUS
}
pexpression_mult = { pexpression_unary ~ (pexpression_mult_op ~ pexpression_unary)* }
pexpression_mult_op = {
      ASTERISK
      | SLASH
}
pexpression_unary = {
      pexpression_unary_op ~ pexpression_term
      | pexpression_func
}
pexpression_unary_op = {
      MINUS
      | TILDE
}
pexpression_func = {
      pexpression_apply
      | pexpression_term
}
pexpression_apply = { identifier ~ pexpression_operands }
pexpression_operands = { LPAREN ~ (pexpression ~ (COMMA ~ pexpression)*)? ~ RPAREN }
pexpression_term = {
      identifier
    | integer
    | LPAREN ~ pexpression ~ RPAREN
}
pexpression2 = { pexpression2_or }
pexpression2_or = { pexpression2_xor ~ (pexpression2_or_op ~ pexpression2_xor)* }
pexpression2_or_op = { SPEC_OR }
pexpression2_xor = { pexpression2_and ~ (pexpression2_xor_op ~ pexpression2_and)* }
pexpression2_xor_op = { SPEC_XOR }
pexpression2_and = { pexpression2_shift ~ (pexpression2_and_op ~ pexpression2_shift)* }
pexpression2_and_op = { SPEC_AND }
pexpression2_shift = { pexpression2_add ~ (pexpression2_shift_op ~ pexpression2_add)* }
pexpression2_shift_op = {
      LEFT
    | RIGHT
}
pexpression2_add = { pexpression2_mult ~ (pexpression2_add_op ~ pexpression2_mult)* }
pexpression2_add_op = {
      PLUS
    | MINUS
}
pexpression2_mult = { pexpression2_unary ~ (pexpression2_mult_op ~ pexpression2_unary)* }
pexpression2_mult_op = {
      ASTERISK
    | SLASH
}
pexpression2_unary = {
      pexpression2_unary_op ~ pexpression2_term
    |	pexpression2_func
}
pexpression2_unary_op = {
      MINUS
    | TILDE
}
pexpression2_func = {
      pexpression2_apply
    |	pexpression2_term
}
pexpression2_apply = { identifier ~ pexpression2_operands }
pexpression2_operands = { LPAREN ~ (pexpression2 ~ (COMMA ~ pexpression2)*)? ~ RPAREN }
pexpression2_term = {
      identifier
    |	integer
    |	LPAREN ~ pexpression2 ~ RPAREN
}

id_or_wild = { identifier | wildcard }
wildcard = { UNDERSCORE }
identifier = _{ strict_id | key_as_id }
key_as_id = {
      KEY_ALIGNMENT
    | KEY_ATTACH
    | KEY_BIG
    | KEY_BITRANGE
    | KEY_BUILD
    | KEY_CALL
    | KEY_CONTEXT
    | KEY_CROSSBUILD
    | KEY_DEC
    | KEY_DEFAULT
    | KEY_DEFINE
    | KEY_ENDIAN
    | KEY_EXPORT
    | KEY_GOTO
    | KEY_HEX
    | KEY_LITTLE
    | KEY_LOCAL
    | KEY_MACRO
    | KEY_NAMES
    | KEY_NOFLOW
    | KEY_OFFSET
    | KEY_PCODEOP
    | KEY_RETURN
    | KEY_SIGNED
    | KEY_SIZE
    | KEY_SPACE
    | KEY_TOKEN
    | KEY_TYPE
    | KEY_UNIMPL
    | KEY_VALUES
    | KEY_VARIABLES
    | KEY_WORDSIZE
}
strict_id = _{ IDENTIFIER }
integer = _{ HEX_INT | DEC_INT | BIN_INT }

// Preprocessor-generated directives
pp_position = ${ PP_ESCAPE ~ PP_FILE ~ "###" ~ PP_LINE ~ PP_ESCAPE }
PP_FILE = { (!(NEWLINE | PP_ESCAPE | "###") ~ ANY)* }
PP_LINE = { ASCII_DIGIT+ }
PP_ESCAPE = _{ "\x08" }

// Reserved words and keywords
RES_WITH = _{ "with" }

KEY_ALIGNMENT = _{ "alignment" }
KEY_ATTACH = _{ "attach" }
KEY_BIG = { "big" }
KEY_BITRANGE = _{ "bitrange" }
KEY_BUILD = _{ "build" }
KEY_CALL = _{ "call" }
KEY_CONTEXT = _{ "context" }
KEY_CROSSBUILD = _{ "crossbuild" }
KEY_DEC = _{ "dec" }
KEY_DEFAULT = { "default" }
KEY_DEFINE = _{ "define" }
KEY_ENDIAN = _{ "endian" }
KEY_EXPORT = _{ "export" }
KEY_GOTO = _{ "goto" }
KEY_HEX = _{ "hex" }
KEY_LITTLE = { "little" }
KEY_LOCAL = _{ "local" }
KEY_MACRO = _{ "macro" }
KEY_NAMES = _{ "names" }
KEY_NOFLOW = _{ "noflow" }
KEY_OFFSET = _{ "offset" }
KEY_PCODEOP = _{ "pcodeop" }
KEY_RETURN = _{ "return" }
KEY_SIGNED = _{ "signed" }
KEY_SIZE = _{ "size" }
KEY_SPACE = _{ "space" }
KEY_TOKEN = _{ "token" }
KEY_TYPE = _{ "type" }
KEY_UNIMPL = _{ "unimpl" }
KEY_VALUES = _{ "values" }
KEY_VARIABLES = _{ "variables" }
KEY_WORDSIZE = _{ "wordsize" }

// Grouping, block, and sectioning symbols
LBRACE = _{ "_{" }
RBRACE = _{ "}" }
LBRACKET = _{ "[" }
RBRACKET = _{ "]" }
LPAREN = _{ "(" }
RPAREN = _{ ")" }

// Miscellaneous
ELLIPSIS = _{ "..." }
UNDERSCORE = { "_" }
COLON = _{ ":" }
COMMA = _{ "," }
EXCLAIM = _{ "!" }
TILDE = _{ "~" }
SEMI = _{ ";" }

// ----------
// Operators:
// ----------

ASSIGN = _{ "=" }

// Comparisons
EQUAL = _{ "==" }
NOTEQUAL = _{ "!=" }
LESS = _{ "<" }
GREAT = _{ ">" }
LESSEQUAL = _{ "<=" }
GREATEQUAL = _{ ">=" }

// Boolean and bitwise logic operations
BOOL_OR = _{ "||" }
BOOL_XOR = _{ "^^" }
BOOL_AND = _{ "&&" }
PIPE = _{ "|" }
CARET = _{ "^" }
AMPERSAND = _{ "&" }

// Shifting operations
LEFT = _{ "<<" }
RIGHT = _{ ">>" }

// Arithmetic operations
PLUS = _{ "+" }
MINUS = { "-" }
ASTERISK = _{ "*" }
SLASH = _{ "/" }
PERCENT = _{ "%" }

// Explicitly named boolean operations
SPEC_OR = _{ "$or" }
SPEC_AND = _{ "$and" }
SPEC_XOR = _{ "$xor" }

// IDs, Literals
IDENTIFIER = @{ !(UNDERSCORE ~ &(!IDENTIFIER | EOI)) ~ ALPHA_UP ~ (ALPHA_UP | ASCII_DIGIT )* }
ALPHA_UP = { ASCII_ALPHA | "_" | "." }
qstring = ${ "\"" ~ STRING ~ "\"" }
STRING = @{ (ESCAPE | STRING_TEXT)* }
STRING_TEXT = { !("\\" | "\"") ~ ANY }
ESCAPE = {
      "\\" ~ ("b" | "t" | "n" | "f" | "r" | "\"" | "'" | "\\")
    | UNICODE_ESCAPE
    | OCTAL_ESCAPE
}
UNICODE_ESCAPE = { "\\" ~ "u" ~ ASCII_HEX_DIGIT{4} }
OCTAL_ESCAPE = { "\\" ~ ('0'..'3')? ~ ASCII_OCT_DIGIT{1,2} }
DEC_INT = @{ ASCII_DIGIT+ }
HEX_INT = @{ "0x" ~ ASCII_HEX_DIGIT+ }
BIN_INT = @{ "0b" ~ ASCII_BIN_DIGIT+ }
