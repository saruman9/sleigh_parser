use super::lexer::{LexicalError, Token};
use super::ast::{Endian, Term, FieldMod};
use super::location;

grammar;

extern {
    type Location = location::Location;
    type Error = LexicalError;

    enum Token {
        "with" => Token::With,
        "alignment" => Token::Alignment,
        "attach" => Token::Attach,
        "big" => Token::Big,
        "bitrange" => Token::Bitrange,
        "build" => Token::Build,
        "call" => Token::Call,
        "context" => Token::Context,
        "crossbuild" => Token::Crossbuild,
        "dec" => Token::Dec,
        "default" => Token::Default,
        "define" => Token::Define,
        "endian" => Token::Endian,
        "export" => Token::Export,
        "goto" => Token::GoTo,
        "hex" => Token::Hex,
        "little" => Token::Little,
        "local" => Token::Local,
        "macro" => Token::Macro,
        "names" => Token::Names,
        "noflow" => Token::NoFlow,
        "offset" => Token::Offset,
        "pcodeop" => Token::PCodeOp,
        "return" => Token::Return,
        "signed" => Token::Signed,
        "size" => Token::Size,
        "space" => Token::Space,
        "token" => Token::Token,
        "type" => Token::Type,
        "unimpl" => Token::Unimpl,
        "values" => Token::Values,
        "variables" => Token::Variables,
        "wordsize" => Token::Wordsize,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "..." => Token::Ellipsis,
        "_" => Token::Underscore,
        "," => Token::Comma,
        "!" => Token::Exclaim,
        "~" => Token::Tilde,
        ";" => Token::Semi,
        "=" => Token::Assign,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        ">" => Token::Great,
        "<=" => Token::LessEqual,
        ">=" => Token::GreatEqual,
        "||" => Token::BoolOr,
        "^^" => Token::BoolXor,
        "&&" => Token::BoolAnd,
        "|" => Token::Pipe,
        "^" => Token::Caret,
        "&" => Token::Ampersand,
        "<<" => Token::Left,
        ">>" => Token::Right,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "$or" => Token::SpecOr,
        "$and" => Token::SpecAnd,
        "$xor" => Token::SpecXor,
        Identifier => Token::Identifier(<String>),
        QString => Token::QString(<String>),
        DecInt => Token::DecInt(<String>),
        HexInt => Token::HexInt(<String>),
        BinInt => Token::BinInt(<String>),
    }
}

pub Spec: Box<Term> = {
    <e:endiandef> <def:definition_or_constructorlike*> => Box::new(Term::Spec(e, def)),
}

definition_or_constructorlike: Term = {
    definition,
    // constructorlike,
}

endiandef: Box<Term> = {
    "define" "endian" "=" <endian> ";" => Box::new(Term::Endian(<>)),
}

endian: Box<Endian> = {
    "big" => Box::new(Endian::Big),
    "little" => Box::new(Endian::Little),
}

definition: Term = {
    <aligndef> ";",
    <tokendef> ";",
    // <contextdef> ";",
    // spacedef SEMI,
    // varnodedef SEMI,
    // bitrangedef SEMI,
    // pcodeopdef SEMI,
    // valueattach SEMI,
    // nameattach SEMI,
    // varattach SEMI,
}

aligndef: Term = {
    "define" "alignment" "=" <integer> => Term::Alignment(<>),
}

tokendef: Term = {
    "define" "token" <i:identifier> "(" <int:integer> ")" <f:fielddefs> => Term::Token(i, int, f),
}

fielddefs: Box<Term> = {
    fielddef* => Box::new(Term::FieldDefs(<>)),
}

fielddef: Term = {
    <sid:strict_id> "=" "(" <i1:integer> "," <i2:integer> ")" <f:fieldmods> => Term::FieldDef(sid, i1, i2, f),
}

fieldmods: Box<Term> = {
    fieldmod* => Box::new(Term::FieldMods(<>)),
}

fieldmod: FieldMod = {
    "signed" => FieldMod::Signed,
    "hex" => FieldMod::Hex,
    "dec" => FieldMod::Dec,
}

contextfielddefs: Box<Term> = {
    contextfielddef* => Box::new(Term::FieldDefs(<>)),
}

contextfielddef: Term = {
    <id:identifier> "=" "(" <i1:integer> "," <i2:integer> ")" <m:contextfieldmods> => Term::FieldDef(<>),
}

contextfieldmods: Box<Term> = {
    contextfieldmod* => Box::new(Term::FieldMods(<>)),
}

contextfieldmod: FieldMod = {
    "signed" => FieldMod::Signed,
    "noflow" => FieldMod::NoFlow,
    "hex" => FieldMod::Hex,
    "dec" => FieldMod::Dec,
}

contextdef: Box<Term> = {
    "define" "context" <id:identifier> <fd:contextfielddefs> => Box::new(Term::Context(id, fd)),
}

// constructorlike = {
//     macrodef,
//     // withblock,
//     // constructor,
// }

// macrodef = {
//     KEY_MACRO identifier LPAREN arguments RPAREN semanticbody,
// }

// semanticbody = {
//     "semantic",
// }

// arguments = {
//     oplist?,
// }

// oplist = {
//     identifier (COMMA identifier)*,
// }

identifier: Box<Term> = {
    strict_id,
    key_as_id,
}

key_as_id: Box<Term> = {
    "alignment" => Box::new(Term::Identifier("alignment".to_string())),
    "attach" => Box::new(Term::Identifier("attach".to_string())),
    "big" => Box::new(Term::Identifier("big".to_string())),
    "bitrange" => Box::new(Term::Identifier("bitrange".to_string())),
    "build" => Box::new(Term::Identifier("build".to_string())),
    "call" => Box::new(Term::Identifier("call".to_string())),
    "context" => Box::new(Term::Identifier("context".to_string())),
    "crossbuild" => Box::new(Term::Identifier("crossbuild".to_string())),
    "dec" => Box::new(Term::Identifier("dec".to_string())),
    "default" => Box::new(Term::Identifier("default".to_string())),
    "define" => Box::new(Term::Identifier("define".to_string())),
    "endian" => Box::new(Term::Identifier("endian".to_string())),
    "export" => Box::new(Term::Identifier("export".to_string())),
    "goto" => Box::new(Term::Identifier("goto".to_string())),
    "hex" => Box::new(Term::Identifier("hex".to_string())),
    "little" => Box::new(Term::Identifier("little".to_string())),
    "local" => Box::new(Term::Identifier("local".to_string())),
    "macro" => Box::new(Term::Identifier("macro".to_string())),
    "names" => Box::new(Term::Identifier("names".to_string())),
    "noflow" => Box::new(Term::Identifier("noflow".to_string())),
    "offset" => Box::new(Term::Identifier("offset".to_string())),
    "pcodeop" => Box::new(Term::Identifier("pcodeop".to_string())),
    "return" => Box::new(Term::Identifier("return".to_string())),
    "signed" => Box::new(Term::Identifier("signed".to_string())),
    "size" => Box::new(Term::Identifier("size".to_string())),
    "space" => Box::new(Term::Identifier("space".to_string())),
    "token" => Box::new(Term::Identifier("token".to_string())),
    "type" => Box::new(Term::Identifier("type".to_string())),
    "unimpl" => Box::new(Term::Identifier("unimpl".to_string())),
    "values" => Box::new(Term::Identifier("values".to_string())),
    "variables" => Box::new(Term::Identifier("variables".to_string())),
    "wordsize" => Box::new(Term::Identifier("wordsize".to_string())),
}

strict_id: Box<Term> = {
    Identifier => Box::new(Term::Identifier(<>.to_string())),
}

integer: Box<Term> = {
    HexInt => Box::new(Term::HexConstant(<>.to_string())),
    DecInt => Box::new(Term::DecConstant(<>.to_string())),
    BinInt => Box::new(Term::BinConstant(<>.to_string())),
}
