use super::lexer::{LexicalError, Token};
use super::ast::{Term, Endian};

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "with" => Token::With,
        "alignment" => Token::Alignment,
        "attach" => Token::Attach,
        "big" => Token::Big,
        "bitrange" => Token::Bitrange,
        "build" => Token::Build,
        "call" => Token::Call,
        "context" => Token::Context,
        "crossbuild" => Token::Crossbuild,
        "dec" => Token::Dec,
        "default" => Token::Default,
        "define" => Token::Define,
        "endian" => Token::Endian,
        "export" => Token::Export,
        "goto" => Token::GoTo,
        "hex" => Token::Hex,
        "little" => Token::Little,
        "local" => Token::Local,
        "macro" => Token::Macro,
        "names" => Token::Names,
        "noflow" => Token::NoFlow,
        "offset" => Token::Offset,
        "pcodeop" => Token::PCodeOp,
        "return" => Token::Return,
        "signed" => Token::Signed,
        "size" => Token::Size,
        "space" => Token::Space,
        "token" => Token::Token,
        "type" => Token::Type,
        "unimpl" => Token::Unimpl,
        "values" => Token::Values,
        "variables" => Token::Variables,
        "wordsize" => Token::Wordsize,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "..." => Token::Ellipsis,
        "_" => Token::Underscore,
        ":" => Token::Colon,
        "," => Token::Comma,
        "!" => Token::Exclaim,
        "~" => Token::Tilde,
        ";" => Token::Semi,
        "=" => Token::Assign,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "<" => Token::Less,
        ">" => Token::Great,
        "<=" => Token::LessEqual,
        ">=" => Token::GreatEqual,
        "||" => Token::BoolOr,
        "^^" => Token::BoolXor,
        "&&" => Token::BoolAnd,
        "|" => Token::Pipe,
        "^" => Token::Caret,
        "&" => Token::Ampersand,
        "<<" => Token::Left,
        ">>" => Token::Right,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "$or" => Token::SpecOr,
        "$and" => Token::SpecAnd,
        "$xor" => Token::SpecXor,
        Identifier => Token::Identifier(<&'input str>),
        QString => Token::QString(<String>),
        DecInt => Token::DecInt(<&'input str>),
        HexInt => Token::HexInt(<&'input str>),
        BinInt => Token::BinInt(<&'input str>),
    }
}

pub Spec = {
    endiandef definition_or_constructorlike*,
}

definition_or_constructorlike = {
    definition,
    // constructorlike,
}

endiandef = {
    "define" "endian" "=" <endian> ";",
}

endian: Endian = {
    "big" => Endian::Big,
    "little" => Endian::Little,
}

definition = {
    aligndef ";",
    // tokendef ";",
    // contextdef ";",
    // spacedef SEMI,
    // varnodedef SEMI,
    // bitrangedef SEMI,
    // pcodeopdef SEMI,
    // valueattach SEMI,
    // nameattach SEMI,
    // varattach SEMI,
}

aligndef = {
    "define" "alignment" "=" integer,
}

tokendef = {
    "define" "token" identifier "(" integer ")" fielddefs,
}

fielddefs = {
    fielddef*,
}

fielddef = {
    strict_id "=" "(" integer "," integer ")" fieldmods,
}

fieldmods = {
    fieldmod*,
}

fieldmod = {
    "signed",
    "hex",
    "dec",
}

contextfielddefs = {
    contextfielddef*,
}

contextfielddef = {
    identifier "=" "(" integer "," integer ")" contextfieldmods,
}

contextfieldmods = {
    contextfieldmod*,
}

contextfieldmod = {
    "signed",
    "noflow",
    "hex",
    "dec",
}

contextdef = {
    "define" "context" identifier contextfielddefs,
}

// constructorlike = {
//     macrodef,
//     // withblock,
//     // constructor,
// }

// macrodef = {
//     KEY_MACRO identifier LPAREN arguments RPAREN semanticbody,
// }

// semanticbody = {
//     "semantic",
// }

// arguments = {
//     oplist?,
// }

// oplist = {
//     identifier (COMMA identifier)*,
// }

identifier = {
    strict_id,
    key_as_id,
}

key_as_id: &'input str = {
    "alignment" => "alignment",
    "attach" => "attach",
    "big" => "big",
    "bitrange" => "bitrange",
    "build" => "build",
    "call" => "call",
    "context" => "context",
    "crossbuild" => "crossbuild",
    "dec" => "dec",
    "default" => "default",
    "define" => "define",
    "endian" => "endian",
    "export" => "export",
    "goto" => "goto",
    "hex" => "hex",
    "little" => "little",
    "local" => "local",
    "macro" => "macro",
    "names" => "names",
    "noflow" => "noflow",
    "offset" => "offset",
    "pcodeop" => "pcodeop",
    "return" => "return",
    "signed" => "signed",
    "size" => "size",
    "space" => "space",
    "token" => "token",
    "type" => "type",
    "unimpl" => "unimpl",
    "values" => "values",
    "variables" => "variables",
    "wordsize" => "wordsize",
}

strict_id = {
    Identifier,
}

integer = {
    HexInt,
    DecInt,
    BinInt,
}
