use std::collections::HashMap;

use lalrpop_util::ParseError;

use crate::errors::Error;

grammar(definitions: &'input HashMap<String, String>);

extern {
    type Error = Error;
}

pub expression: bool = {
    expr => <>,
};

expr: bool = {
    expr_or => <>,
};

expr_or: bool = {
    <lhs:expr_xor> "||" <rhs:expr_xor> => lhs || rhs,
    expr_xor => <>,
};

expr_xor: bool = {
    <lhs:expr_and> "^^" <rhs:expr_and> => lhs ^ rhs,
    expr_and => <>,
};

expr_and: bool = {
    <lhs:expr_not> "&&" <rhs:expr_not> => lhs && rhs,
    expr_not => <>,
};

expr_not: bool = {
    "!" <e:expr_paren> => !e,
    expr_paren => <>,
    expr_eq => <>,
    "defined" "(" <id:identifier> ")" => definitions.contains_key(id),
};

expr_paren: bool = {
    "(" <e:expr> ")" => e,
};

expr_eq: bool = {
    <lhs:expr_term> "==" <rhs:expr_term> => lhs == rhs,
    <lhs:expr_term> "!=" <rhs:expr_term> => lhs != rhs,
};

expr_term: &'input str = {
    <id:identifier> =>? definitions
        .get(id)
        .map(AsRef::as_ref)
        .ok_or(
            ParseError::User {
                error: Error::NotDefined(id.to_string()),
            }
        ),
    <qs:qstring> => qs.trim_matches('\"'),
};

identifier = {
    r"[a-zA-Z_0-9]+",
};

qstring = {
    r#""[^"]*""#,
};

// string: () = {
//     escape,
//     r#"[^\\"]."#,
// };

// escape: () = {
//     r#"\\[btnfr"'\\]"#,
//     unicode_escape,
//     octal_escape,
// };

// octal_escape: () = {
//     r"\\[0-3][0-7]{2}",
//     r"\\[0-7]{1,2}",
// };

// unicode_escape: () = {
//     r"\\u[0-9a-fA-F]{4}"
// };

match {
    r"[ \t\r\n]+" => { },
} else {
    _
}
